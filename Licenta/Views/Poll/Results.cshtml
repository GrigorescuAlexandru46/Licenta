@model Licenta.Models.Poll

@{ int i = 1; }

<script src="/Content/d3/d3.js"></script>
<script src="/Content/d3/d3-geo-projection.v2.min.js"></script>
<script src="/Content/d3/d3-scale-chromatic.v1.min.js"></script>
<script src="/Content/d3/d3.layout.cloud.js"></script>


<script>
    var submissionCount = @ViewBag.SubmissionCount;

    var questionsJson = {
        @foreach (var question in Model.Questions)
        {
            <text>"@(question.QuestionId)": [</text>
            foreach (var answer in question.Answers)
            {
                <text>"@(answer.AnswerId)",</text>
            }
            <text>],</text>

        }
    };

    var questionsTypeJson = {
        @foreach (var question in Model.Questions)
        {
            <text>"@(question.QuestionId)": @(question.QuestionType), </text>
        }
    };

    var answersJson = {
        @foreach (var question in Model.Questions)
        {
            foreach (var answer in question.Answers)
            {
                <text>"@(answer.AnswerId)": "@(answer.Text)",</text>
            }
        }
    };

    var answerCountJson = {
        @foreach (KeyValuePair<int, int> entry in ViewBag.AnswerSelectedCountMap)
        {
            <text>"@(entry.Key)": @(entry.Value),</text>
        }
    };

    var answersPercentageJson = {
        @foreach (KeyValuePair<int, double> entry in ViewBag.AnswerPercentageMap)
        {
            <text>"@(entry.Key)": @(entry.Value),</text>
        }
    };

    var customAnswerCountJson = {
        @foreach (KeyValuePair<int, Dictionary<string, int>> entry in ViewBag.CustomAnswerMap)
        {
            <text>"@(entry.Key)": {</text>
            foreach (KeyValuePair<string, int> internalEntry in entry.Value)
            {
                <text>"@(internalEntry.Key)": @(internalEntry.Value),</text>
            }
            <text>},</text>
        }
    };

    var customAnswersPercentageJson = {
        @foreach (KeyValuePair<int, Dictionary<string, double>> entry in ViewBag.CustomAnswerPercentageMap)
        {
            <text>"@(entry.Key)": {</text>
            foreach (KeyValuePair<string, double> internalEntry in entry.Value)
            {
                <text>"@(internalEntry.Key)": @(internalEntry.Value),</text>
            }
            <text>},</text>
        }
    };

    var combinationsJson = {
        @foreach (KeyValuePair<Tuple<int, int>, int> entry in ViewBag.AnswerCombinationCountList)
        {
            Tuple<int, int> combination = entry.Key;
            int count = entry.Value;

            <text>"@combination.Item1-@combination.Item2": @count,</text>
        }
    };

    var combinationsPercentageJson = {
        @foreach (KeyValuePair<Tuple<int, int>, double> entry in ViewBag.AnswerCombinationPercentageMap)
        {
            Tuple<int, int> combination = entry.Key;
            double percentage = entry.Value;

            <text>"@combination.Item1-@combination.Item2": @percentage,</text>
        }
    };

    var answerObjectsMapChartJson = {
        @foreach (KeyValuePair<Tuple<double, double>, Dictionary<int, Dictionary<string, Dictionary<string, object>>>> entry in ViewBag.AnswerObjectsMapChart)
        {
            <text>"(@(entry.Key.Item1),@(entry.Key.Item2))": {</text>
            foreach (KeyValuePair<int, Dictionary<string, Dictionary<string, object>>> innerEntry in entry.Value) {
                <text>"@(innerEntry.Key)": {</text>
                foreach (KeyValuePair<string, Dictionary<string, object>> extraInnerEntry in innerEntry.Value)
                {
                    <text>"@(extraInnerEntry.Key)": {</text>
                    foreach(KeyValuePair<string, object> superExtraInnerEntry in extraInnerEntry.Value)
                    {
                        if (superExtraInnerEntry.Key == "value")
                        {
                            <text>@(superExtraInnerEntry.Key): @(superExtraInnerEntry.Value),</text>
                        }
                        else
                        {
                            <text>@(superExtraInnerEntry.Key): "@(superExtraInnerEntry.Value)",</text>
                        }
                    }
                    <text>},</text>
                }
                <text>},</text>
            }
            <text>},</text>
        }
    };
</script>

<script>
    var lastColorObjectId = -1;

    function generateRandomColorObject() {
        var colorsObject = {
            0: {
                color: "rgba(255, 99, 132, 0.5)",
                border: "rgba(255, 99, 132, 1)"
            },

            1: {
                color: "rgba(54, 162, 235, 0.5)",
                border: "rgba(54, 162, 235, 1)"
            },

            2: {
                color: "rgba(255, 206, 86, 0.5)",
                border: "rgba(255, 206, 86, 1)"
            },

            3: {
                color: "rgba(75, 192, 192, 0.5)",
                border: "rgba(75, 192, 192, 1)"
            },

            4: {
                color: "rgba(153, 102, 255, 0.5)",
                border: "rgba(153, 102, 255, 1)"
            },

            5: {
                color: "rgba(255, 159, 64, 0.5)",
                border: "rgba(255, 159, 64, 1)"
            }
        };

        var randomColorObjectId = 0;

        // Make sure we don't generate the same color twice
        do {
            randomColorObjectId = Math.floor(Math.random() * 6);
        } while (randomColorObjectId == lastColorObjectId)

        // Save the new color as the last color generated
        lastColorObjectId = randomColorObjectId;

        return colorsObject[randomColorObjectId];
    }

    function extractQuestionId(stringTagId) {

        var stringMatches = stringTagId.match(/(\d+)/);
        var stringQuestionId = stringMatches[0];

        var numberQuestionId = parseInt(stringQuestionId, 10);
        numberQuestionId = isNaN(numberQuestionId) ? 0 : numberQuestionId;

        return numberQuestionId;
    }

    function generateRandomColorHsl() {
        var hue;
        var saturation;
        var lightness;

        do {
            hue = Math.floor(Math.random() * 360);
        } while (40 < hue && hue < 100)

        saturation = Math.floor(Math.random() * 80) + 20;
        lightness = Math.floor(Math.random() * 40) + 20;

        return "hsl(" + hue + ", " + saturation + "%, " + lightness + "%)";
    }

    function truncateOptions() {
        var optionList = document.getElementsByTagName("option");

        for (let option of optionList) {
            if (option.innerHTML.length > 35) {
                option.innerHTML = option.innerHTML.slice(0, 31);
                option.innerHTML = option.innerHTML.concat(" ...");
            }
        }
    }

    function isEquivalent(a, b) {
        // Create arrays of property names
        var aProps = Object.getOwnPropertyNames(a);
        var bProps = Object.getOwnPropertyNames(b);

        // If number of properties is different,
        // objects are not equivalent
        if (aProps.length != bProps.length) {
            return false;
        }

        for (var i = 0; i < aProps.length; i++) {
            var propName = aProps[i];

            // If values of same property are not equal,
            // objects are not equivalent
            if (a[propName] !== b[propName]) {
                return false;
            }
        }

        // If we made it this far, objects
        // are considered equivalent
        return true;
    }

    function arrayEquals(a, b) {

        if (!Array.isArray(a) || !Array.isArray(b) || a.length != b.length) {
            return false;
        }

        for (let i = 0; i < a.length; i++) {    
            var tempA = {
                answerCount: a[i].answerCount,
                answerPercentage: a[i].answerPercentage,
                text: a[i].text,
            };

            var tempB = {
                answerCount: b[i].answerCount,
                answerPercentage: b[i].answerPercentage,
                text: b[i].text,
            };

            if (!isEquivalent(tempA, tempB)) {
                return false;
            }
        }

        return true;
    }

    function countProperties(obj) {
        var count = 0;

        for (var prop in obj) {
            if (obj.hasOwnProperty(prop))
                ++count;
        }

        return count;
    }
</script>

<script>
    var globalMargin = {};
    var globalWidth = 0;
    var globalHeight = 0;
    var globalChartDimensions = {};

    var updateInterval;

    window.onload = function () {
        truncateOptions();

        // Create chart dimensions object
        var firstQuestionId = Object.keys(questionsJson)[0];
        var tempDivChart = document.getElementById("divChart" + firstQuestionId);
        tempDivChart.style.height = "60vh";
        globalMargin = { top: 30, right: 30, bottom: 70, left: 60 };
        globalWidth = tempDivChart.offsetWidth - globalMargin.left - globalMargin.right;
        globalHeight = tempDivChart.offsetHeight - globalMargin.top - globalMargin.bottom;
        globalChartDimensions = { "margin": globalMargin, "width": globalWidth, "height": globalHeight };

        // Create all charts
        for (var questionId in questionsJson) {
            if (questionsJson.hasOwnProperty(questionId)) {
                // Create chart
                if (questionsTypeJson[questionId] != 3) {
                    createBarChart(questionId, gatherData(questionId), globalChartDimensions);
                }
                else {
                    if (containsOnlyNumbers(questionId)) {
                        createNumbersChart(questionId, gatherDataNumbersChart(questionId), globalChartDimensions);
                    }
                    else {
                        createWordCloud(questionId, gatherDataWordCloud(questionId), globalChartDimensions);
                    }
                }
            }
        }

        updateInterval = setInterval(updateResults, 5000);
    }

    function gatherData(questionId) {
        var data = [];

        questionsJson[questionId].forEach(function (answerId) {
            data.push({
                answerText: answersJson[answerId],
                answerCount: answerCountJson[answerId],
                answerId: answerId
            });
        });

        return data;
    }

    function gatherDataCompare(currentQuestionId, comparedQuestionId) {
        var data = [];

        questionsJson[currentQuestionId].forEach(function (currentAnswerId) {
            var obj = {};

            obj.group = answersJson[currentAnswerId];
            questionsJson[comparedQuestionId].forEach(function (comparedAnswerId) {
                obj[answersJson[comparedAnswerId]] = {
                    value: combinationsJson[currentAnswerId + "-" + comparedAnswerId],
                    percentage: combinationsPercentageJson[currentAnswerId + "-" + comparedAnswerId]
                };
            });

            data.push(obj);
        });

        data.columns = [];
        data.columns.push("group");
        questionsJson[comparedQuestionId].forEach(function (comparedAnswerId) {
            data.columns.push(answersJson[comparedAnswerId]);
        });

        return data;
    }

    function gatherDataMap(questionId) {
        var data = [];

        Object.keys(answerObjectsMapChartJson).forEach(function (coordsString) {
            var questionObjects = answerObjectsMapChartJson[coordsString];

            var latitude = parseFloat(coordsString.substring(1, coordsString.indexOf(",")));
            var longitude = parseFloat(coordsString.substring(coordsString.indexOf(",") + 1, coordsString.length - 1));

            var answerObjects = questionObjects[questionId];

            Object.keys(answerObjects).forEach(function (answerText) {
                var currentAnswerObject = answerObjects[answerText];

                var answerCount = currentAnswerObject.value;
                var answerCountry = currentAnswerObject.country;
                var answerCity = currentAnswerObject.city;

                if (answerCount > 0) {
                    data.push({
                        lat: latitude,
                        long: longitude,
                        label: answerText,
                        value: answerCount,
                        country: answerCountry,
                        city: answerCity
                    });
                }
            });
        });

        return data;
    }

    function gatherDataWordCloud(questionId) {
        var data = [];

        Object.keys(customAnswerCountJson[questionId]).forEach(function (answerText) {
            var answerCount = customAnswerCountJson[questionId][answerText];
            var answerPercentage = customAnswersPercentageJson[questionId][answerText];

            data.push({
                text: answerText,
                size: answerCount,
                percentage: answerPercentage
            });
        });

        return data;
    }

    function gatherDataNumbersChart(questionId) {

    }

    function calculateTicks(max) {
        if (max == 1) { return 1; }
        if (max < 5) { return 2; }
        if (max < 10) { return 5; }
        return 10;
    }

    function removeChart(questionId) {
        var divChart = document.getElementById("divChart" + questionId);
        var svg = divChart.getElementsByTagName("svg")[0];

        divChart.removeChild(svg);
    }

    function createBarChart(questionId, receivedData, chartDimensions) {
        // Set dimensions
        var margin = chartDimensions["margin"];
        var width = chartDimensions["width"];
        var height = chartDimensions["height"];

        // Create Svg and group
        var svg = d3.select("#divChart" + questionId)
            .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // Create and append X axis
        var xAxis = d3.scaleBand()
            .range([0, width])
            .domain(receivedData.map(function (d) { return d.answerText; }))
            .padding(0.2);
        svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(xAxis))
            .selectAll("text")
                .attr("class", "font-weight-bold")
                .attr("transform", "translate(-10,0)rotate(-45)")
                .style("text-anchor", "end")
                .style("font-size", "1rem");

        // Create and append Y axis
        var yAxis = d3.scaleLinear()
            .domain([0, submissionCount])
            .range([height, 0]);
        svg.append("g")
            .attr("class", "y-axis")
            .call(d3.axisLeft(yAxis)
                .ticks(calculateTicks(submissionCount))
                .tickFormat(d3.format("d")));

        // create a tooltip
        var tooltip = d3.select("body")
            .append("div")
                .attr("class", "font-weight-bold text-dark px-2 py-2")
                .style("position", "absolute")
                .style("z-index", "10")
                .style("visibility", "hidden")
                .style("background", "lavender")
                .style("border", "1px solid gray")
                .style("border-radius", "12px")
                .style("text-align", "center")
                .style("visibility", "hidden")
                .on("mousemove", function () { return tooltip.style("top", (event.pageY - 75) + "px").style("left", (event.pageX) + 5 + "px"); });

        // Generate random color
        var colorObject = generateRandomColorObject();

        // Create and append bars
        svg.selectAll("rect").data(receivedData)
            .enter()
            .append("g")
                    .attr("class", "barGroup")
                    .append("rect")
                        .attr("x", function (d) { return xAxis(d.answerText); })
                        .attr("y", function (d) { return yAxis(0); })
                        .attr("width", xAxis.bandwidth())
                        .attr("height", function (d) { return height - yAxis(0); })
                        .attr("fill", colorObject.border)
                        .attr("fill-opacity", .5)
                        .style("stroke", colorObject.border)
                        .style("stroke-width", 1)
                        .on("mouseover", function (d) { d3.select(this).style("fill-opacity", .7).style("stroke-width", 3); return tooltip.style("visibility", "visible").html(d.answerText + ": " + d.answerCount + "<hr class='my-1' />" + answersPercentageJson[d.answerId].toFixed(2) + "%"); })
                        .on("mousemove", function () { return tooltip.style("top", (event.pageY - 75) + "px").style("left", (event.pageX) + 5 + "px"); })
                        .on("mouseout", function (d) { d3.select(this).style("fill-opacity", .5).style("stroke-width", 1); return tooltip.style("visibility", "hidden").html(""); })
                        .transition().duration(1500)
                            .attr("y", function (d) { return yAxis(d.answerCount); })
                            .attr("height", function (d) { return height - yAxis(d.answerCount); })
                            .delay(function (d, i) { return (i * 100) });

        // Append text to each bar
        svg.selectAll(".barGroup").data(receivedData)
            .append("text")
                .attr("x", function (d) { return xAxis(d.answerText) + xAxis.bandwidth() / 2; })
                .attr("y", function (d) { return yAxis(d.answerCount - (submissionCount / 10)); })
                .attr("font-size", "2vw")
                .attr("text-anchor", "middle")
                .attr("font-family", "cursive")
                .style("fill", "white")
                .style("opacity", 0)
                .style("cursor", "default")
                .text(function (d) { return (d.answerCount > 0 ? Math.round(answersPercentageJson[d.answerId]) + "%" : ""); })
                .transition().duration(1500)
                    .delay(1500)
                    .style("opacity", 1.0);
    }

    function updateBarChart(questionId, receivedData, chartDimensions) {
        // Select svg
        var svg = d3.select("#divChart" + questionId).select("svg");

        // Select the outdated Y axis
        var outdatedYaxis = svg.select("g.y-axis");

        var margin = chartDimensions["margin"];
        var width = chartDimensions["width"];
        var height = chartDimensions["height"];

        // Create new Y axis
        var newYaxis = d3.scaleLinear()
            .domain([0, submissionCount])
            .range([height, 0]);

        // Update Y axis
        outdatedYaxis
            .transition().duration(1500)
            .call(d3.axisLeft(newYaxis)
                .ticks(calculateTicks(submissionCount))
                .tickFormat(d3.format("d")));

        // Update values
        svg.selectAll("rect").data(receivedData)
            .transition()
            .duration(1500)
            .attr("y", function (d) { return newYaxis(d.answerCount); })
            .attr("height", function (d) { return height - newYaxis(d.answerCount); })

        // Update text for each bar
        svg.selectAll(".barGroup").data(receivedData)
            .select("text")
            .transition().duration(1500)
            .attr("y", function (d) { return newYaxis(d.answerCount - (submissionCount / 10)); })
            .text(function (d) { return (d.answerCount > 0 ? Math.round(answersPercentageJson[d.answerId]) + "%" : ""); });
    };

    function createBarChartCompare(questionId, receivedData, chartDimensions) {
        // Set dimensions
        var margin = chartDimensions["margin"];
        var svgWidth = chartDimensions["width"];
        var width = (Math.round(svgWidth - window.innerWidth / 12)) - globalMargin.left - globalMargin.right;
        var height = chartDimensions["height"];

        // append the svg object to the body of the page
        var svg = d3.select("#divChart" + questionId)
            .append("svg")
            .attr("width", svgWidth + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
            .append("g")
                  .attr("class", "chartGroup")
                  .attr("width", width + margin.left + margin.right)
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // List of subgroups
        var subgroups = receivedData.columns.slice(1);

        // List of groups = I show them on the X axis
        var groups = d3.map(receivedData, function (d) { return (d.group) }).keys();

        // Add X axis
        var x = d3.scaleBand()
            .domain(groups)
            .range([0, width])
            .padding([0.2])
        svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x).tickSize(0))
            .selectAll("text")
            .attr("class", "font-weight-bold")
            .attr("transform", "translate(-10,0)rotate(-45)")
            .style("text-anchor", "end")
            .style("font-size", "1rem");

        // Add Y axis
        var y = d3.scaleLinear()
            .domain([0, submissionCount])
            .range([height, 0]);
        svg.append("g")
            .attr("class", "y-axis")
            .call(d3.axisLeft(y)
                .ticks(calculateTicks(submissionCount))
                .tickFormat(d3.format("d")));

        // Another scale for subgroup position
        var xSubgroup = d3.scaleBand()
            .domain(subgroups)
            .range([0, x.bandwidth()])
            .padding([0.05])

        // color palette = one color per subgroup
        var colorFill = d3.scaleOrdinal()
            .domain(subgroups)
            .range(["rgb(255, 0, 0, 0.5)", "rgb(0, 102, 255, 0.5)", "rgb(51, 204, 51, 0.5)", "rgb(255, 204, 0, 0.5)", "rgb(153, 51, 255, 0.5)", "rgb(102, 255, 255, 0.5)", "rgb(204, 153, 255, 0.5)", "rgb(0, 102, 102, 0.5)", "rgb(153, 204, 0, 0.5)", "rgb(102, 51, 0, 0.5)", "rgb(255, 51, 204, 0.5)", "rgb(153, 204, 255, 0.5)", "rgb(153, 255, 153, 0.5)", "rgb(204, 51, 0, 0.5)", "rgb(0, 0, 102, 0.5)", "rgb(153, 102, 0, 0.5)", "rgb(0, 102, 34, 0.5)", "rgb(102, 102, 153, 0.5)", "rgb(255, 255, 77, 0.5)", "rgb(255, 153, 255, 0.5)"]);

        // border color palette = one color per subgroup
        var colorBorder = d3.scaleOrdinal()
            .domain(subgroups)
            .range(["rgb(255, 0, 0, 1.0)", "rgb(0, 102, 255, 1.0)", "rgb(51, 204, 51, 1.0)", "rgb(255, 204, 0, 1.0)", "rgb(153, 51, 255, 1.0)", "rgb(102, 255, 255, 1.0)", "rgb(204, 153, 255, 1.0)", "rgb(0, 102, 102, 1.0)", "rgb(153, 204, 0, 1.0)", "rgb(102, 51, 0, 1.0)", "rgb(255, 51, 204, 1.0)", "rgb(153, 204, 255, 1.0)", "rgb(153, 255, 153, 1.0)", "rgb(204, 51, 0, 1.0)", "rgb(0, 0, 102, 1.0)", "rgb(153, 102, 0, 1.0)", "rgb(0, 102, 34, 1.0)", "rgb(102, 102, 153, 1.0)", "rgb(255, 255, 77, 1.0)", "rgb(255, 153, 255, 1.0)"]);

        // create a tooltip
        var tooltip = d3.select("body")
            .append("div")
            .attr("class", "font-weight-bold text-dark px-2 py-2")
            .style("position", "absolute")
            .style("z-index", "10")
            .style("visibility", "hidden")
            .style("background", "lavender")
            .style("border", "1px solid gray")
            .style("border-radius", "12px")
            .style("text-align", "center")
            .style("visibility", "hidden")
            .style("visibility", "hidden")
            .style("visibility", "hidden")
            .on("mousemove", function () { return tooltip.style("top", (event.pageY - 75) + "px").style("left", (event.pageX) + 5 + "px"); });

        // Show the bars
        svg.append("g")
            .attr("class", "innerChartGroup")
            .selectAll("myg")
            // Enter in data = loop group per group
            .data(receivedData)
            .enter()
            .append("g")
            .attr("class", "labelGroup")
            .attr("transform", function (d) { return "translate(" + x(d.group) + ",0)"; })
            .selectAll("rect")
            .data(function (d) { return subgroups.map(function (key) { return { key: key, value: d[key].value, percentage: d[key].percentage }; }); })
            .enter()
            .append("g")
            .attr("class", "barGroup")
            .append("rect")
            .attr("x", function (d) { return xSubgroup(d.key); })
            .attr("y", function (d) { return y(0); })
            .attr("width", xSubgroup.bandwidth())
            .attr("height", function (d) { return height - y(0); })
            .attr("fill", function (d) { return colorBorder(d.key); })
            .attr("fill-opacity", .5)
            .style("stroke", function (d) { return colorBorder(d.key); })
            .style("stroke-width", 1)
            .on("mouseover", function (d) { d3.select(this).style("fill-opacity", .7).style("stroke-width", 2); return tooltip.style("visibility", "visible").html(d.key + ": " + d.value + "<hr class='my-1' />" + d.percentage.toFixed(2) + "%"); })
            .on("mousemove", function () { return tooltip.style("top", (event.pageY - 75) + "px").style("left", (event.pageX) + 5 + "px"); })
            .on("mouseout", function (d) { d3.select(this).style("fill-opacity", .5).style("stroke-width", 1); return tooltip.style("visibility", "hidden").html(""); })
            .transition().duration(1500)
                .attr("y", function (d) { return y(d.value); })
                .attr("height", function (d) { return height - y(d.value); });


        // Append text to each bar
        svg.selectAll(".labelGroup").data(receivedData)
            .selectAll(".barGroup").data(function (d) { return subgroups.map(function (key) { return { key: key, value: d[key].value, percentage: d[key].percentage }; }); })
            .append("text")
            .attr("x", function (d) { return xSubgroup(d.key) + xSubgroup.bandwidth() / 2; })
            .attr("y", function (d) { return y(d.value - (submissionCount / 20)); })
            .attr("font-size", "1.2vw")
            .attr("text-anchor", "middle")
            .attr("font-family", "cursive")
            .style("fill", "white")
            .style("opacity", 0)
            .style("pointer-events", "none")
            .text(function (d) { return (d.value > 0 ? Math.round(d.percentage) + "%" : ""); })
            .transition().duration(1500)
            .delay(1500)
            .style("opacity", 1.0);

        var legendX = Math.round(svg.node().getBBox().width + 60);
        var legendY = 0;

        // Legend
        var legendGroup = d3.select("#divChart" + questionId).select("svg")
            .append("g")
            .attr("class", "legendGroup")
            .attr("transform", "translate(" + (legendX) + ", " + legendY + ")");

        legendGroup
            .append("g")
            .attr("class", "left")
            .selectAll("mydots")
            .data(subgroups)
            .enter()
            .append("circle")
            .attr("cx", 0)
            .attr("cy", function (d, i) { return 100 + i * 25; })
            .attr("r", 7)
            .style("fill", function (d) { return colorFill(d) });

        legendGroup
            .append("g")
            .attr("class", "right")
            .attr("transform", "translate(" + 15 + ", " + legendY + ")")
            .selectAll("myLabels")
            .data(subgroups)
            .enter()
            .append("text")
            .attr("x", 0)
            .attr("y", function (d, i) { return 100 + i * 25; })
            .style("fill", function (d) { return colorFill(d) })
            .text(function (d) { return d })
            .attr("text-anchor", "left")
            .style("alignment-baseline", "middle")
            .attr("font-family", "cursive");
    }

    function updateBarChartCompare(questionId, receivedData, chartDimensions) {
        var height = chartDimensions["height"];

        // Select chart g from inside svg
        var svg = d3.select("#divChart" + questionId).select("svg").select(".chartGroup")

        // Select the outdated Y axis
        var outdatedYaxis = svg.select("g.y-axis");

        // List of subgroups
        var subgroups = receivedData.columns.slice(1);

        // List of groups = I show them on the X axis
        var groups = d3.map(receivedData, function (d) { return (d.group) }).keys();

        // Create new Y axis using new data
        var y = d3.scaleLinear()
            .domain([0, submissionCount])
            .range([height, 0]);

        // Update old Y axis using new Y axis
        outdatedYaxis
            .transition().duration(1500)
            .call(d3.axisLeft(y)
                .ticks(calculateTicks(submissionCount))
                .tickFormat(d3.format("d"))
            );

        // Update the bars
        svg.select(".innerChartGroup").selectAll(".labelGroup").data(receivedData)
            .selectAll("rect").data(function (d) { return subgroups.map(function (key) { return { key: key, value: d[key].value, percentage: d[key].percentage }; }); })
            .transition().duration(1500)
                .attr("y", function (d) { return y(d.value); })
                .attr("height", function (d) { return height - y(d.value); });

        // Update percentage text for each bar
        svg.selectAll(".labelGroup").data(receivedData)
            .selectAll(".barGroup").data(function (d) { return subgroups.map(function (key) { return { key: key, value: d[key].value, percentage: d[key].percentage }; }); })
                .select("text")
                .transition().duration(1500)
                .attr("y", function (d) { return y(d.value - (submissionCount / 20)); })
                .text(function (d) { return (d.value > 0 ? Math.round(d.percentage) + "%" : ""); })

        console.log("Update compare");
    }

    function createMapChart(questionId, receivedData, chartDimensions) {
        // ?????????????????????ordinea
        // List of labels
        var labels = [];
        receivedData.forEach(function (obj) {
            if (!labels.includes(obj.label)) {
                labels.push(obj.label);
            }
        });

        // Set dimensions
        var margin = chartDimensions["margin"];
        var width = chartDimensions["width"];
        var height = chartDimensions["height"];

        // Create Svg and group
        var svg = d3.select("#divChart" + questionId).append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.bottom + margin.top);

        svg
            .style("fill-opacity", 0)
            .transition().duration(1000)
            .style("fill-opacity", 1);

        // Create color palette
        var color = d3.scaleOrdinal()
            .domain(labels)
            .range(["rgb(255, 0, 0, 1.0)", "rgb(0, 102, 255, 1.0)", "rgb(51, 204, 51, 1.0)", "rgb(255, 204, 0, 1.0)", "rgb(153, 51, 255, 1.0)", "rgb(102, 255, 255, 1.0)", "rgb(204, 153, 255, 1.0)", "rgb(0, 102, 102, 1.0)", "rgb(153, 204, 0, 1.0)", "rgb(102, 51, 0, 1.0)", "rgb(255, 51, 204, 1.0)", "rgb(153, 204, 255, 1.0)", "rgb(153, 255, 153, 1.0)", "rgb(204, 51, 0, 1.0)", "rgb(0, 0, 102, 1.0)", "rgb(153, 102, 0, 1.0)", "rgb(0, 102, 34, 1.0)", "rgb(102, 102, 153, 1.0)", "rgb(255, 255, 77, 1.0)", "rgb(255, 153, 255, 1.0)"]);

        // Add a scale for bubble size
        var circleSize = d3.scaleLinear()
            .domain([1, 30])  // What's in the data
            .range([10, 20])  // Size in pixel

        // Map and projection
        var projection = d3.geoNaturalEarth()
            .scale(width / 1.3 / Math.PI)
            .translate([width / 2, height / 2 + margin.top + margin.bottom])

        // create a tooltip
        var tooltip = d3.select("body")
            .append("div")
            .attr("class", "font-weight-bold text-dark px-2 py-2")
            .style("position", "absolute")
            .style("z-index", "10")
            .style("visibility", "hidden")
            .style("background", "lavender")
            .style("border", "1px solid gray")
            .style("border-radius", "12px")
            .style("text-align", "center")
            .style("visibility", "hidden")
            .on("mousemove", function () { return tooltip.style("top", (event.pageY - 75) + "px").style("left", (event.pageX) + 5 + "px"); });

        // Load map drawing data
        d3.json("/Content/d3/world_geojson.json", function (data) {

            // Draw the map
            svg.append("g")
                .selectAll("path")
                .data(data.features)
                .enter().append("path")
                .attr("fill", "#C0C0C0")
                .attr("d", d3.geoPath()
                    .projection(projection)
                )
                .style("stroke", "#fff")

            // Add circles:
            svg
                .selectAll("myCircles")
                .data(receivedData)
                .enter()
                .append("circle")
                .attr("class", function (d) { return "grp" + d.label })
                .attr("cx", function (d) { return projection([d.long, d.lat])[0] })
                .attr("cy", function (d) { return projection([d.long, d.lat])[1] })
                .attr("r", 0)
                .style("fill", function (d) { return color(d.label); })
                .attr("stroke", function (d) { return color(d.label); })
                .attr("stroke-width", 1)
                .attr("fill-opacity", .5)
                .on("mouseover", function (d) { d3.select(this).style("stroke", "black").style("fill-opacity", .8); return tooltip.style("visibility", "visible").html(d.label + ": " + d.value + "<hr class='my-1' />" + d.country + ", " + d.city); })
                .on("mousemove", function () { return tooltip.style("top", (event.pageY - 75) + "px").style("left", (event.pageX) + 5 + "px"); })
                .on("mouseout", function (d) { d3.select(this).style("stroke", color(d.label)).style("fill-opacity", .5); return tooltip.style("visibility", "hidden").html(""); });

            var initialGrp = d3.select("#selectLabelMap" + questionId).property("value");
            svg.selectAll("." + initialGrp)
                .transition().duration(1000)
                .style("opacity", 1)
                .attr("r", function (d) { return circleSize(d.value) })

            d3.select("#selectLabelMap" + questionId)
                .on("change", function () {
                    grp = event.target.value;

                    d3.selectAll("circle")
                        .transition().duration(1000)
                        .style("opacity", 0).attr("r", 0)

                    svg.selectAll("." + grp)
                        .transition().duration(1000)
                        .style("opacity", 1)
                        .attr("r", function (d) { return circleSize(d.value) })
                });
        });
    }

    function createWordCloud(questionId, receivedData, chartDimensions) {
        // Set dimensions
        var margin = chartDimensions["margin"];
        var width = chartDimensions["width"];
        var height = chartDimensions["height"];

        // append the svg object to the body of the page
        var svg = d3.select("#divChart" + questionId).append("svg")
            .attr("class", "border border-primary rounded")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // Create a scale for text size
        var textSize = d3.scaleLinear()
            .domain([1, 30])  // What's in the data
            .range([8, 40])  // Size in pixel

        // create a tooltip
        var tooltip = d3.select("body")
            .append("div")
            .attr("class", "font-weight-bold text-dark px-2 py-2")
            .style("position", "absolute")
            .style("z-index", "10")
            .style("visibility", "hidden")
            .style("background", "lavender")
            .style("border", "1px solid gray")
            .style("border-radius", "12px")
            .style("text-align", "center")
            .style("visibility", "hidden")
            .on("mousemove", function () { return tooltip.style("top", (event.pageY - 75) + "px").style("left", (event.pageX) + 5 + "px"); });

        var minAngleValue = -50;
        var maxAngleValue = 50;

        // Constructs a new cloud layout instance. It run an algorithm to find the position of words that suits your requirements
        var layout = d3.layout.cloud()
            .size([width, height])
            .words(receivedData.map(function (d) { return { text: d.text, size: textSize(d.size), answerCount: d.size, answerPercentage: d.percentage }; }))
            .padding(20)
            .rotate(function (d) { return Math.floor(Math.random() * (maxAngleValue - minAngleValue + 1)) + minAngleValue; })
            .fontSize(function (d) { return textSize(d.size); })
            .on("end", function (words) {
                // This function takes the output of 'layout' above and draw the words
                // Better not to touch it. To change parameters, play with the 'layout' variable above
                svg
                    .append("g")
                    .attr("transform", "translate(" + layout.size()[0] / 2 + "," + layout.size()[1] / 2 + ")")
                    .selectAll("text")
                    .data(words)
                    .enter().append("text")
                    .on("mouseover", function (d) { d3.select(this).style("fill-opacity", 1.0); return tooltip.style("visibility", "visible").html(d.text + ": " + d.answerCount + "<hr class='my-1' />" + d.answerPercentage.toFixed(2) + "%"); })
                    .on("mousemove", function () { return tooltip.style("top", (event.pageY - 75) + "px").style("left", (event.pageX) + 5 + "px"); })
                    .on("mouseout", function (d) { d3.select(this).style("fill-opacity", .6); return tooltip.style("visibility", "hidden").html(""); })
                    .style("font-size", function (d) { return textSize(d.size); })
                    .style("fill", function (d) { return generateRandomColorHsl(); })
                    .attr("fill-opacity", .6)
                    .attr("text-anchor", "middle")
                    .attr("font-family", "impact")
                    .style("cursor", "default")
                    .text(function (d) { return d.text; })
                    .transition().duration(1000)
                    .attr("transform", function (d) { return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")"; });    
            });
        layout.start();
    }

    function updateWordCloud(questionId, receivedData, chartDimensions) {
        // Set dimensions
        var margin = chartDimensions["margin"];
        var width = chartDimensions["width"];
        var height = chartDimensions["height"];

        // Select svg g
        var svg = d3.select("#divChart" + questionId).select("g");

        // Create a scale for text size
        var textSize = d3.scaleLinear()
            .domain([1, 30])  // What's in the data
            .range([8, 40])  // Size in pixel

        // create a tooltip
        var tooltip = d3.select("body")
            .append("div")
            .attr("class", "font-weight-bold text-dark px-2 py-2")
            .style("position", "absolute")
            .style("z-index", "10")
            .style("visibility", "hidden")
            .style("background", "lavender")
            .style("border", "1px solid gray")
            .style("border-radius", "12px")
            .style("text-align", "center")
            .style("visibility", "hidden")
            .on("mousemove", function () { return tooltip.style("top", (event.pageY - 75) + "px").style("left", (event.pageX) + 5 + "px"); });

        var minAngleValue = -50;
        var maxAngleValue = 50;
        
        // Constructs a new cloud layout instance. It run an algorithm to find the position of words that suits your requirements
        var layout = d3.layout.cloud()
            .size([width, height])
            .words(receivedData.map(function (d) { return { text: d.text, size: textSize(d.size), answerCount: d.size, answerPercentage: d.percentage }; }))
            .padding(20)
            .rotate(function (d) { return Math.floor(Math.random() * (maxAngleValue - minAngleValue + 1)) + minAngleValue; })
            .fontSize(function (d) { return textSize(d.size); })
            .on("end", function (words) {
                svg.select("g").selectAll("text")
                    .transition().duration(1000)
                    .attr("transform", function (d) { return "translate(" + [0, 0] + ")rotate(" + 0 + ")"; })
                    .remove();

                setTimeout(function () { svg.select("g").remove(); }, 1000);
                

                svg
                    .append("g")
                    .attr("transform", "translate(" + layout.size()[0] / 2 + "," + layout.size()[1] / 2 + ")")
                    .selectAll("text")
                    .data(words)
                    .enter().append("text")
                    .on("mouseover", function (d) { d3.select(this).style("fill-opacity", 1.0); return tooltip.style("visibility", "visible").html(d.text + ": " + d.answerCount + "<hr class='my-1' />" + d.answerPercentage.toFixed(2) + "%"); })
                    .on("mousemove", function () { return tooltip.style("top", (event.pageY - 75) + "px").style("left", (event.pageX) + 5 + "px"); })
                    .on("mouseout", function (d) { d3.select(this).style("fill-opacity", .6); return tooltip.style("visibility", "hidden").html(""); })
                    .style("font-size", function (d) { return textSize(d.size); })
                    .style("fill", function (d) { return generateRandomColorHsl(); })
                    .attr("fill-opacity", 0)
                    .attr("text-anchor", "middle")
                    .attr("font-family", "impact")
                    .style("cursor", "default")
                    .text(function (d) { return d.text; })
                    .transition().duration(1000).delay(300)
                    .attr("fill-opacity", .6)
                    .transition().duration(1000)
                    .attr("transform", function (d) { return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")"; });
            });
        layout.start();

        console.log("Update word cloud");
    }

    function createNumbersChart(questionId, receivedData, chartDimensions) {
        alert("Numbers chart");
    }

    function changeChartType() {
        resetIntervalTimer();

        var select = event.target;
        var questionId = extractQuestionId(select.id);

        if (select.value == "barChart") {
            removeChart(questionId);
            createBarChart(questionId, gatherData(questionId), globalChartDimensions);

            document.getElementById("divSelectLabelMap" + questionId).style.display = "none";
            document.getElementById("divCompareQuestion" + questionId).style.display = "block";

            document.getElementById("selectCompareQuestion" + questionId).value = -1;
            return;
        }

        if (select.value == "mapChart") {
            removeChart(questionId);
            createMapChart(questionId, gatherDataMap(questionId), globalChartDimensions);

            document.getElementById("divCompareQuestion" + questionId).style.display = "none";
            document.getElementById("divSelectLabelMap" + questionId).style.display = "block";
        }
    }

    function compareQuestion() {
        resetIntervalTimer();

        var select = event.target;
        var currentQuestionId = extractQuestionId(select.id);
        var comparedQuestionId = select.value;

        if (comparedQuestionId == -1) {
            removeChart(currentQuestionId);
            createBarChart(currentQuestionId, gatherData(currentQuestionId), globalChartDimensions);
        } else {
            removeChart(currentQuestionId);
            createBarChartCompare(currentQuestionId, gatherDataCompare(currentQuestionId, comparedQuestionId), globalChartDimensions);
        }
    }

    function containsOnlyNumbers(questionId) {
        var customAnswersObj = customAnswerCountJson[questionId];

        customAnswersObj = {
            "3": 3,
            "2": 5,
            "5": 2,
            "6": 5,
            "12": 2
        };

        for (var key in customAnswersObj) {
            if (customAnswersObj.hasOwnProperty(key)) {
                if (isNaN(key)) {
                    return false;
                }
            }
        }

        return true;
    }

    function resetIntervalTimer() {
        clearInterval(updateInterval);
        updateInterval = setInterval(updateResults, 5000);
    }

    function updateResults() {
        $.ajax({
            type: "POST",
            url: "/Poll/UpdateResults/@(Model.PollId)",
            data: null,
            dataType: "json",
            contentType: 'application/json; charset=utf-8',
            success: function (data) {
                var dataJson;

                try {
                    // Try converting string to js object
                    dataJson = JSON.parse(data);

                    var mustUpdateWordCloud = false;
                    if (!(JSON.stringify(customAnswerCountJson) === JSON.stringify(dataJson["customAnswerMapJson"]))) {
                        mustUpdateWordCloud = true;
                    }

                    // Update js objects
                    submissionCount = dataJson["submissionCount"];
                    answerCountJson = dataJson["answerSelectedCountMapJson"];
                    combinationsJson = dataJson["answerCombinationCountListJson"];
                    customAnswerCountJson = dataJson["customAnswerMapJson"];
                    answersPercentageJson = dataJson["answerPercentageMapJson"];
                    customAnswersPercentageJson = dataJson["customAnswerPercentageMapJson"];
                    combinationsPercentageJson = dataJson["answerCombinationPercentageMapJson"];
                }
                catch (err) {
                    if (err instanceof SyntaxError) {
                        console.log("No submissions - No update");
                    }
                    else {
                        console.log("Error - No update");
                    }

                    return;
                }

                // Update each chart
                for (var questionId in questionsJson) {
                    if (questionsJson.hasOwnProperty(questionId)) {
                        if (questionsTypeJson[questionId] != 3) {
                            var chartType = document.getElementById("selectChartType" + questionId).value;

                            if (chartType == "barChart") {
                                var comparedQuestionId = document.getElementById("selectCompareQuestion" + questionId).value;

                                if (comparedQuestionId == -1) {
                                    updateBarChart(questionId, gatherData(questionId), globalChartDimensions);
                                } else {
                                    updateBarChartCompare(questionId, gatherDataCompare(questionId, comparedQuestionId), globalChartDimensions);
                                }
                            }
                        }
                        else {
                            if (mustUpdateWordCloud) {
                                updateWordCloud(questionId, gatherDataWordCloud(questionId), globalChartDimensions);
                            }
                        }
                    }
                }

                console.log("Update");
            },
            error: function () {
                alert("There was an error while attempting to update live results")
            }
        });
    }

</script>

<br />
<h1 class="text-center display-3 font-weight-bold">Results</h1>
<hr />

@foreach (var question in Model.Questions)
{
    <div class="jumbotron">
        <div class="row">
            <div class="col-12">
                <h1 class="text-center font-weight-bold cut-text">Question @i</h1>
            </div>
        </div>

        <div class="row mt-5 mb-4 ml-3">
            <div class="col-12">
                <div class="d-block d-sm-none">
                    <h5 class="font-weight-bold">@question.Text</h5>
                </div>
                <div class="d-none d-sm-block d-md-none">
                    <h4 class="text-justify font-weight-bold">@question.Text</h4>
                </div>
                <div class="d-none d-md-block">
                    <h3 class="text-justify font-weight-bold">@question.Text</h3>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-12">
                <div id="divChart@(question.QuestionId)"></div>
            </div>
        </div>

        @if (question.QuestionType != 3)
        {

            <hr class="mt-5" />

            <div id="rowSelect" class="row ml-3 pb-1">
                <div class="col-12 col-md-6">
                    <span class="font-weight-bold">Chart type</span>
                    <select class="form-control" id="selectChartType@(question.QuestionId)" onchange="changeChartType()">
                        <option value="barChart">Bar chart</option>
                        <option value="mapChart">Map chart</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                    </select>
                </div>
                <div id="divCompareQuestion@(question.QuestionId)" class="col-12 col-md-6">
                    <span class="font-weight-bold">Compare results to:</span>
                    <select class="form-control" id="selectCompareQuestion@(question.QuestionId)" onchange="compareQuestion()">
                        <option value="-1">None</option>
                        @foreach (var compareQuestion in Model.Questions)
                        {
                            if (compareQuestion.QuestionType != 3 && compareQuestion.QuestionId != question.QuestionId)
                            {
                                <option value="@(compareQuestion.QuestionId)">@compareQuestion.Text</option>
                            }
                        }
                    </select>
                </div>
                <div id="divSelectLabelMap@(question.QuestionId)" class="col-12 col-md-6" style="display: none">
                    <div class="row">
                        <div class="col-12 mb-2">
                            <span class="font-weight-bold">Visible labels:</span>
                            <select class="form-control" id="selectLabelMap@(question.QuestionId)">
                                @foreach (var answer in question.Answers)
                                {
                                    <option value="grp@(answer.Text)">@answer.Text</option>
                                }
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        }
    </div>
    i++;
}


